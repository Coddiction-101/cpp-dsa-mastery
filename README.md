THE COMPLETE ROADMAP
HOW TO USE THIS ROADMAP

Follow the order below - Don't skip ahead
Complete each section before moving to next
Build the projects listed at each level
Track progress in PROGRESS.md

Time Commitment: 2-3 hours daily for 4-6 months

LEVEL 1: C++ FUNDAMENTALS (WEEKS 1-2)
What to Learn
Week 1: Core Basics

Variables, data types (int, float, double, char, string, bool)
Input/output (cin, cout)
Operators (arithmetic, relational, logical, assignment)
If-else statements
Switch-case statements
Loops (for, while, do-while)
Break and continue

Week 2: Functions & Arrays

Functions (declaration, definition, calling)
Function parameters (pass by value, pass by reference)
Return types
Recursion basics
1D arrays (declaration, initialization, traversal)
2D arrays (matrix operations)
Strings (C++ string class, basic operations)

Learning Method
Each day:

Learn 2-3 concepts (read/watch tutorials)
Write 5-10 small programs practicing those concepts
Solve 2-3 basic problems

Practice Problems (30 total)
Variables & I/O:

Simple calculator (add, subtract, multiply, divide)
Temperature converter (Celsius to Fahrenheit)
Swap two numbers
Area and perimeter of shapes

Control Flow:

Check even/odd
Find largest of 3 numbers
Grade calculator
Leap year checker
Print patterns (pyramid, diamond)
Multiplication table

Loops:

Sum of n numbers
Factorial
Fibonacci series
Prime number checker
Print all divisors

Functions:

Function for each above problem
Power calculator (x^n)
GCD and LCM
Palindrome number

Arrays:

Find largest/smallest element
Array sum and average
Reverse an array
Linear search
Count even/odd elements
Matrix addition
Matrix multiplication
Transpose matrix

Strings:

Count vowels and consonants
Reverse a string
Check palindrome
Count words in sentence

Mini Projects (Build 2)
Project 1: Student Grade Calculator

Input: Student marks in 5 subjects
Calculate: Total, average, percentage
Output: Grade (A/B/C/D/F based on percentage)
Features: Multiple students, highest/lowest scorer

Project 2: Simple Banking System

Create account (name, account number, balance)
Deposit money
Withdraw money
Check balance
Display account details

Mastery Criteria

Can write any basic program without looking at reference
Understand when to use loops vs recursion
Comfortable with arrays and strings
Can break problems into functions


LEVEL 2: INTERMEDIATE C++ (WEEKS 3-4)
What to Learn
Week 3: Pointers & Memory

Pointer basics (declaration, dereferencing)
Pointer arithmetic
Pointers and arrays
Pointers and functions
Dynamic memory allocation (new, delete)
Memory leaks and how to avoid them
References (&)
Pass by reference vs pass by pointer

Week 4: OOP Fundamentals

Classes and objects
Access specifiers (public, private, protected)
Constructors (default, parameterized, copy)
Destructors
This pointer
Static members
Encapsulation
Basic inheritance
Function overloading

Practice Problems (25 total)
Pointers:

Swap using pointers
Reverse array using pointers
Find max using pointers
Dynamic array creation
2D dynamic array

OOP:

Create Rectangle class (length, width, area, perimeter)
Bank Account class (deposit, withdraw, balance)
Student class (name, roll, marks, grade)
Book class (title, author, price, discount)
Employee class (name, id, salary, bonus)

Projects (Build 2)
Project 3: Library Management System

Book class (title, author, ISBN, available)
Add book
Search book by title/author
Issue book
Return book
Display all books
Save to file, load from file

Project 4: Contact Management System

Contact class (name, phone, email, address)
Add contact
Search contact
Update contact
Delete contact
Display all contacts
Sort by name
File persistence

Mastery Criteria

Understand pointer vs reference
Can implement any class with proper encapsulation
Know when to use dynamic memory
Can design simple class hierarchies


LEVEL 3: ADVANCED C++ (WEEK 5)
What to Learn
STL (Standard Template Library)

Vector (dynamic arrays)
String (advanced operations)
Pair
Stack
Queue
Deque
Map (ordered key-value)
Unordered_map (hash map)
Set (ordered unique elements)
Unordered_set (hash set)
Iterators
Common algorithms (sort, reverse, find, binary_search)

File Handling

File streams (ifstream, ofstream, fstream)
Reading from files
Writing to files
File modes
Error handling

Practice Problems (20 total)
Vector:

Dynamic student records
Remove duplicates
Frequency counter

Map/Set:

Character frequency
Word frequency
First non-repeating character

Stack:

Balanced parentheses
Reverse string

Queue:

First non-repeating character in stream

Algorithms:

Sort array of custom objects
Binary search in sorted array
Find in unsorted array

Project (Build 1)
Project 5: To-Do List Application

Use vector to store tasks
Use map for categories
Task class (name, priority, deadline, completed)
Add task
Mark complete
Delete task
View by priority
View by category
Filter by status
Save/load from file
Statistics (total, completed, pending)

Mastery Criteria

Can choose right container for the problem
Understand time complexity of STL operations
Comfortable with iterators
Can read/write complex data to files


LEVEL 4: BASIC DSA - ARRAYS (WEEKS 6-8)
What to Learn
Array Techniques

Two pointers technique
Sliding window
Prefix sum
Kadane's algorithm
Dutch National Flag (3-way partitioning)
Binary search and variants
Basic sorting (bubble, selection, insertion)
Advanced sorting (merge sort, quick sort)

Time & Space Complexity

Big O notation
Best, average, worst case
Analyzing loops
Analyzing recursion

Core Problems (50 - Based on your tracker)
Phase 1: Foundation (10)

Remove Duplicates from Sorted Array
Remove Element
Merge Sorted Array
Rotate Array
Move Zeroes
Binary Search
Search Insert Position
Find Peak Element
Sort Colors (Dutch Flag)
Contains Duplicate

Phase 2: Core Patterns (15)
Two Pointers (4):
11. Two Sum
12. Two Sum II (sorted array)
13. 3Sum
14. Container With Most Water
Sliding Window (4):
15. Best Time to Buy and Sell Stock
16. Longest Substring Without Repeating Characters
17. Minimum Size Subarray Sum
18. Longest Repeating Character Replacement
Prefix Sum (2):
19. Subarray Sum Equals K
20. Product of Array Except Self
Kadane's Algorithm (2):
21. Maximum Subarray
22. Maximum Product Subarray
Matrix (3):
23. Spiral Matrix
24. Rotate Image
25. Set Matrix Zeroes
Phase 3: Interview Favorites (15)
26. Merge Intervals
27. Insert Interval
28. Longest Consecutive Sequence
29. Majority Element
30. Jump Game
31. Jump Game II
32. Trapping Rain Water
33. Search in Rotated Sorted Array
34. First Missing Positive
35. Find Duplicate Number
36. Gas Station
37. Task Scheduler
38. Daily Temperatures
39. Largest Rectangle in Histogram
40. Group Anagrams
Phase 4: Advanced (10)
41. Minimum Window Substring
42. Sliding Window Maximum
43. Median of Two Sorted Arrays
44. Count of Smaller Numbers After Self
45. Reverse Pairs
46. Count of Range Sum
47. The Skyline Problem
48. Maximal Rectangle
49. Trapping Rain Water II
50. Split Array Largest Sum
Learning Approach
Daily routine:

Learn one technique/pattern
Solve 2-3 related problems
Write notes on the pattern
Identify when to use it

Problem-solving template:
1. Understand the problem (read 2-3 times)
2. Identify the pattern (two pointers? sliding window?)
3. Think of brute force first
4. Optimize using the pattern
5. Code the solution
6. Test with examples
7. Analyze complexity
Project (Build 1)
Project 6: Array Visualizer

Visualize array operations (CLI based)
Show sorting step-by-step (bubble, merge, quick)
Show two-pointer movement
Show sliding window movement
Animations using sleep/clear screen
Performance comparison of algorithms

Mastery Criteria

Solved 40+ out of 50 problems
Can identify pattern from problem statement
Know time/space complexity of all techniques
Can explain approach clearly


LEVEL 5: BASIC DSA - LINKED LISTS (WEEKS 9-10)
What to Learn
Linked List Basics

Singly linked list (implementation from scratch)
Doubly linked list
Circular linked list
Dummy node technique
Fast and slow pointer (Floyd's algorithm)

Operations

Insertion (beginning, end, middle)
Deletion (beginning, end, middle, by value)
Traversal
Search
Reverse
Detect and remove cycle
Find middle
Merge two lists

Core Problems (20)
Easy (8):

Reverse Linked List
Middle of Linked List
Merge Two Sorted Lists
Remove Duplicates from Sorted List
Palindrome Linked List
Intersection of Two Linked Lists
Delete Node in Linked List
Remove Linked List Elements

Medium (10):
9. Add Two Numbers
10. Remove Nth Node From End
11. Swap Nodes in Pairs
12. Rotate List
13. Partition List
14. Sort List
15. Reorder List
16. Linked List Cycle II
17. Copy List with Random Pointer
18. Flatten Multilevel Doubly Linked List
Hard (2):
19. Reverse Nodes in k-Group
20. Merge k Sorted Lists
Project (Build 1)
Project 7: Browser History Manager

Doubly linked list for navigation
Visit URL (add to history)
Back button (go to previous)
Forward button (go to next)
Display current page
Clear history
Bookmarks (separate linked list)
Search history
Most visited pages

Mastery Criteria

Can implement any linked list from scratch
Know when to use slow/fast pointers
Solved 15+ problems
Can choose between array and linked list


LEVEL 6: BASIC DSA - STACKS & QUEUES (WEEKS 11-12)
What to Learn
Stack

Array implementation
Linked list implementation
Applications (parentheses, postfix evaluation, undo/redo)
Monotonic stack

Queue

Array implementation
Linked list implementation
Circular queue
Deque (double-ended queue)
Priority queue basics

Core Problems (20)
Stack (10):

Valid Parentheses
Implement Queue using Stacks
Min Stack
Evaluate Reverse Polish Notation
Next Greater Element I
Next Greater Element II
Daily Temperatures
Asteroid Collision
Decode String
Remove K Digits

Queue (7):
11. Implement Stack using Queues
12. Design Circular Queue
13. Number of Recent Calls
14. First Unique Character in Stream
15. Sliding Window Maximum
16. Moving Average from Data Stream
17. Design Hit Counter
Advanced (3):
18. Largest Rectangle in Histogram
19. Maximal Rectangle
20. Trapping Rain Water (using stack)
Project (Build 1)
Project 8: Expression Evaluator

Infix to postfix conversion
Postfix evaluation
Support operators: +, -, *, /, ^, ()
Handle multi-digit numbers
Error detection
Step-by-step evaluation display
Expression history

Mastery Criteria

Can implement stack and queue from scratch
Understand monotonic stack pattern
Solved 15+ problems
Can recognize stack/queue problems


LEVEL 7: INTERMEDIATE DSA - TREES (WEEKS 13-15)
What to Learn
Binary Tree Basics

Node structure
Tree traversals (inorder, preorder, postorder, level-order)
Recursive vs iterative traversals
Tree properties (height, depth, diameter)
Lowest common ancestor

Binary Search Tree

BST property
Insert, search, delete
Validate BST
Kth smallest/largest
Range queries
Convert sorted array to BST

Advanced Trees

AVL tree basics
Trie (prefix tree)
Segment tree basics

Core Problems (25)
Easy (8):

Maximum Depth of Binary Tree
Same Tree
Invert Binary Tree
Symmetric Tree
Balanced Binary Tree
Merge Two Binary Trees
Diameter of Binary Tree
Path Sum

Medium (14):
9. Binary Tree Level Order Traversal
10. Binary Tree Zigzag Level Order
11. Construct Binary Tree from Preorder and Inorder
12. Validate Binary Search Tree
13. Kth Smallest Element in BST
14. Lowest Common Ancestor of Binary Tree
15. Binary Tree Right Side View
16. Count Good Nodes in Binary Tree
17. All Nodes Distance K
18. Delete Node in BST
19. Flatten Binary Tree to Linked List
20. Path Sum II
21. Serialize and Deserialize Binary Tree
22. Implement Trie
Hard (3):
23. Binary Tree Maximum Path Sum
24. Recover Binary Search Tree
25. Vertical Order Traversal
Project (Build 1)
Project 9: File System Navigator

Tree structure for directories and files
Node: name, type (file/folder), size, children
Commands: mkdir, touch, cd, ls, pwd, rm, find
Tree visualization (ASCII art)
Calculate directory size
Search file by name
Path navigation
Save/load file system state

Mastery Criteria

Can implement tree traversals (all 4 types)
Understand BST operations
Solved 18+ problems
Can visualize tree problems


LEVEL 8: INTERMEDIATE DSA - GRAPHS (WEEKS 16-18)
What to Learn
Graph Basics

Graph representation (adjacency list, adjacency matrix)
Directed vs undirected
Weighted vs unweighted
Degree, in-degree, out-degree

Graph Traversals

BFS (Breadth-First Search)
DFS (Depth-First Search)
Connected components
Cycle detection (directed and undirected)

Graph Algorithms

Topological sort (DFS and Kahn's)
Dijkstra's shortest path
Bellman-Ford algorithm
Union-Find (Disjoint Set)
Minimum Spanning Tree (Kruskal's, Prim's)

Core Problems (25)
Easy (6):

Find Center of Star Graph
Find if Path Exists in Graph
All Paths from Source to Target
Find the Town Judge
Number of Provinces
Clone Graph

Medium (15):
7. Number of Islands
8. Max Area of Island
9. Surrounded Regions
10. Pacific Atlantic Water Flow
11. Course Schedule
12. Course Schedule II
13. Minimum Height Trees
14. Network Delay Time
15. Cheapest Flights Within K Stops
16. Path with Maximum Probability
17. Evaluate Division
18. Accounts Merge
19. Redundant Connection
20. Graph Valid Tree
21. Word Ladder
Hard (4):
22. Word Ladder II
23. Alien Dictionary
24. Critical Connections in Network
25. Swim in Rising Water
Project (Build 1)
Project 10: Social Network Analyzer

Graph representation of users and friendships
User node: id, name, friends list
Add user
Add friendship (bidirectional edge)
Remove friendship
Find mutual friends
Shortest path between users (degrees of separation)
Friend suggestions (friends of friends)
Find influencers (most connections)
Community detection (connected components)
Visualize network

Mastery Criteria

Can implement BFS and DFS
Understand when to use which algorithm
Solved 18+ problems
Can model real-world problems as graphs


LEVEL 9: ADVANCED DSA - RECURSION & BACKTRACKING (WEEKS 19-20)
What to Learn
Recursion Patterns

Base case and recursive case
Tree recursion
Tail recursion
Memoization
Recursion vs iteration trade-offs

Backtracking

Backtracking template
State space tree
Pruning
Choice-explore-unchoose pattern

Core Problems (20)
Easy (5):

Fibonacci Number
Power(x, n)
Reverse String (recursive)
Subsets
Permutations

Medium (12):
6. Generate Parentheses
7. Letter Combinations of Phone Number
8. Combination Sum
9. Combination Sum II
10. Combinations
11. Permutations II
12. Subsets II
13. Palindrome Partitioning
14. Word Search
15. N-Queens
16. Sudoku Solver
17. Restore IP Addresses
Hard (3):
18. N-Queens II
19. Regular Expression Matching
20. Wildcard Matching
Project (Build 1)
Project 11: Puzzle Solver

Sudoku solver with visualization
N-Queens solver with board display
Maze generator and solver
Crossword puzzle solver
Show backtracking steps
Count solutions
Performance metrics

Mastery Criteria

Can identify when to use recursion
Understand backtracking template
Solved 15+ problems
Can optimize with memoization


LEVEL 10: ADVANCED DSA - DYNAMIC PROGRAMMING (WEEKS 21-24)
What to Learn
DP Fundamentals

Optimal substructure
Overlapping subproblems
Memoization (top-down)
Tabulation (bottom-up)
State definition
Transition equation

DP Patterns

Linear DP (1D array)
Grid DP (2D array)
Knapsack pattern
LIS pattern (Longest Increasing Subsequence)
LCS pattern (Longest Common Subsequence)
Palindrome pattern
Partition pattern
String matching pattern

Core Problems (30)
Easy (7):

Climbing Stairs
Min Cost Climbing Stairs
House Robber
Best Time to Buy and Sell Stock
Divisor Game
Pascal's Triangle
Fibonacci Number (DP approach)

Medium (18):
8. Longest Increasing Subsequence
9. Longest Common Subsequence
10. Coin Change
11. Coin Change II
12. Unique Paths
13. Unique Paths II
14. Minimum Path Sum
15. Triangle
16. Edit Distance
17. Decode Ways
18. Word Break
19. House Robber II
20. Maximum Product Subarray
21. Jump Game II
22. Longest Palindromic Substring
23. Palindromic Substrings
24. Partition Equal Subset Sum
25. Target Sum
Hard (5):
26. Longest Valid Parentheses
27. Best Time to Buy and Sell Stock III
28. Best Time to Buy and Sell Stock IV
29. Burst Balloons
30. Regular Expression Matching
Project (Build 1)
Project 12: Text Justification Engine

Word wrap algorithm
Knapsack-based line breaking
Different alignment modes
Cost calculation for breaks
Visualization of DP table
Compare greedy vs DP approach

Mastery Criteria

Can define state and transition
Know when to use memoization vs tabulation
Solved 20+ problems
Recognize DP patterns


LEVEL 11: EXPERT DSA - ADVANCED TOPICS (WEEKS 25-26)
What to Learn
Greedy Algorithms

Greedy choice property
Activity selection
Huffman coding
Job scheduling

Bit Manipulation

Bitwise operators
Common tricks (set bit, clear bit, toggle bit)
XOR properties
Counting set bits
Power of 2 checks

Advanced Data Structures

Trie (prefix tree)
Segment tree
Fenwick tree (Binary Indexed Tree)
Disjoint Set Union (Union-Find)

Core Problems (25)
Greedy (8):

Jump Game
Jump Game II
Gas Station
Candy
Task Scheduler
Partition Labels
Non-overlapping Intervals
Minimum Number of Arrows

Bit Manipulation (7):
9. Single Number
10. Number of 1 Bits
11. Counting Bits
12. Reverse Bits
13. Missing Number
14. Sum of Two Integers
15. Single Number II
Advanced DS (10):
16. Implement Trie (Prefix Tree)
17. Word Search II
18. Range Sum Query - Mutable
19. Count of Smaller Numbers After Self
20. The Skyline Problem
21. Design Add and Search Words DS
22. Replace Words
23. Maximum XOR of Two Numbers
24. Number of Connected Components
25. Redundant Connection
Projects (Build 2)
Project 13: Autocomplete System

Trie implementation
Insert words with frequency
Search with prefix
Top k suggestions
Add new words dynamically
Delete words
Persistence

Project 14: File Compression Tool

Huffman coding implementation
Compress text files
Decompress files
Show compression ratio
Binary file handling
Compare with standard algorithms

Mastery Criteria

Understand greedy vs DP trade-offs
Comfortable with bit operations
Can implement Trie from scratch
Solved 18+ problems


FINAL LEVEL: MASTERY & PORTFOLIO (WEEKS 27-30)
Choose ONE Major Project (Week 27-30)
Option 1: Mini Database Management System

B-tree indexing
SQL-like query parser
CRUD operations (Create, Read, Update, Delete)
WHERE clause filtering
JOIN operations
Aggregate functions (SUM, AVG, COUNT)
Transaction support
File-based persistence
Query optimization

Option 2: Code Plagiarism Detector

Tokenize source code
Remove comments and whitespace
Rabin-Karp rolling hash
Calculate similarity percentage
Highlight duplicate blocks
Compare multiple files
Generate detailed report
Support multiple languages

Option 3: Route Optimization System

Graph-based map representation
Dijkstra's shortest path
A* algorithm for faster pathfinding
Multiple stop optimization
Traffic simulation
Real-time route updates
Visualization
Performance metrics

Option 4: AI Game Player

Choose: Chess, Checkers, or Tic-Tac-Toe
Minimax algorithm
Alpha-beta pruning
Evaluation function
Move generation
Game tree exploration
Different difficulty levels
Statistics and analysis


PRACTICE STRATEGY
Problem-Solving Approach
Before Coding:

Read problem 2-3 times
Understand input/output format
Identify constraints
Think of examples
Identify pattern/technique
Think brute force first
Optimize approach

While Coding:

Write clean, readable code
Use meaningful variable names
Add comments for complex logic
Test with examples
Handle edge cases

After Coding:

Analyze time complexity
Analyze space complexity
Test with edge cases
Can you optimize further?
Document your approach

Daily Routine
Weekdays (2-3 hours):

30 min: Learn new concept
60 min: Solve 2 problems
30 min: Review and document

Weekends (3-4 hours):

60 min: Review week's concepts
90 min: Solve harder problems
60 min: Work on project

Weekly Goals

Learn 2-3 new concepts
Solve 10-15 problems
Work 5-6 hours on project
Update progress tracker


RESOURCES
Online Judges
LeetCode - Primary platform

Focus on: Easy and Medium problems
Track: Problems solved by topic
Target: 200+ problems

HackerRank - For fundamentals

Good for learning basics
C++ specific problems

Codeforces - For contests

Participate in contests
Builds speed and accuracy

Documentation
C++ Reference - cppreference.com

Official C++ documentation
STL reference

GeeksforGeeks - geeksforgeeks.org

Concept explanations
Problem editorial

Books (Optional)

"Cracking the Coding Interview" by Gayle McDowell
"Introduction to Algorithms" by CLRS
"C++ Primer" by Lippman


PROGRESS MILESTONES
Month 1

C++ fundamentals complete
OOP basics done
STL comfortable
3 projects built

Month 2

Arrays mastered (40/50 problems)
Linked lists complete (15/20 problems)
2 DSA projects built

Month 3

Stacks/Queues done (15/20 problems)
Trees complete (18/25 problems)
2 projects built

Month 4

Graphs done (18/25 problems)
Recursion complete (15/20 problems)
DP started (10/30 problems)

Month 5

DP mastered (20/30 problems)
Advanced topics covered
2 advanced projects

Month 6

Final portfolio project
Interview prep
Resume ready


SUCCESS CRITERIA
You're ready for interviews when you can:

Language Mastery

Write clean C++ code without reference
Choose right STL container instantly
Understand pointers and memory


Problem Solving

Identify pattern from problem statement
Solve medium problems in 30-45 min
Explain approach clearly


DSA Knowledge

Know time/space complexity of all DS operations
Can implement any DS from scratch
Solved 200+ problems total


Projects

8-10 projects completed
1-2 advanced portfolio projects
Clean code on GitHub




COMMON MISTAKES TO AVOID

Jumping ahead - Master fundamentals first
Tutorial hell - Don't just watch, code yourself
Not tracking progress - Update PROGRESS.md daily
Ignoring complexity - Always analyze time/space
Skipping projects - Projects solidify learning
Copy-pasting - Type everything yourself
Not revising - Review old topics regularly
Giving up - Consistency beats intensity


NEXT STEPS

Read CPP-PROJECTS.md for all C++ project details
Read DSA-PROJECTS.md for all DSA project details
Create PROGRESS.md and start tracking
Start with Level 1, Week 1, Day 1


Remember: This is a marathon, not a sprint. 2-3 hours daily for 6 months will make you interview-ready.
Your journey starts now!

Last Updated: January 27, 2026
Total Learning Time: 300-400 hours over 6 months
Expected Outcome: Interview-ready C++ & DSA skills
